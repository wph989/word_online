# DOCX 格式精确还原规范

## 目标

确保从 DOCX 导入后存储的 JSON 数据能够 **1:1 还原** 原始文档的所有格式信息，包括：
- 可通过 JSON 重新导出为 DOCX 并保持格式一致
- 在前端编辑器中正确渲染所有格式

---

## 一、文本格式精确映射

### 1.1 Run 级别格式（内联格式）

| DOCX 属性 | python-docx API | Content Mark | 值格式 |
|-----------|-----------------|--------------|--------|
| **加粗** | `run.bold` | `SimpleMark(type="bold")` | - |
| **斜体** | `run.italic` | `SimpleMark(type="italic")` | - |
| **下划线** | `run.underline` | `SimpleMark(type="underline")` | - |
| **双下划线** | `run.underline == WD_UNDERLINE.DOUBLE` | `ValueMark(type="underlineStyle", value="double")` | double/wave/dotted 等 |
| **删除线** | `run.font.strike` | `SimpleMark(type="strike")` | - |
| **双删除线** | `run.font.double_strike` | `ValueMark(type="strikeStyle", value="double")` | single/double |
| **上标** | `run.font.superscript` | `SimpleMark(type="superscript")` | - |
| **下标** | `run.font.subscript` | `SimpleMark(type="subscript")` | - |
| **字体颜色** | `run.font.color.rgb` | `ValueMark(type="color", value="rgb(r,g,b)")` | RGB 字符串 |
| **字体颜色(主题)** | `run.font.color.theme_color` | `ValueMark(type="color", value="theme:accent1")` | 主题色标识 |
| **字号** | `run.font.size` | `ValueMark(type="fontSize", value="12pt")` | 保留原始单位 |
| **字体(中文)** | `run.font.name_east_asia` | `ValueMark(type="fontFamily", value="宋体")` | 字体名 |
| **字体(西文)** | `run.font.name` | `ValueMark(type="fontFamily", value="Times New Roman")` | 字体名 |
| **高亮色** | `run.font.highlight_color` | `ValueMark(type="backgroundColor", value="yellow")` | 颜色名/RGB |
| **底纹** | `run.font.shading.fill` | `ValueMark(type="backgroundColor", value="rgb(...))"` | RGB |
| **字符间距** | `run.font.spacing` | `ValueMark(type="letterSpacing", value="2pt")` | pt 单位 |
| **缩放** | `run.font.scale` | `ValueMark(type="textScale", value="150%")` | 百分比 |
| **位置(升降)** | `run.font.position` | `ValueMark(type="textPosition", value="3pt")` | pt 单位 |
| **小型大写** | `run.font.small_caps` | `SimpleMark(type="smallCaps")` | - |
| **全部大写** | `run.font.all_caps` | `SimpleMark(type="allCaps")` | - |
| **隐藏文字** | `run.font.hidden` | `SimpleMark(type="hidden")` | - |
| **着重号** | `run.font.emboss` | `SimpleMark(type="emboss")` | - |
| **阴影** | `run.font.shadow` | `SimpleMark(type="textShadow")` | - |
| **轮廓** | `run.font.outline` | `SimpleMark(type="outline")` | - |

### 1.2 超链接

```python
# DOCX 结构
hyperlink = paragraph.find('.//w:hyperlink')
r_id = hyperlink.get(qn('r:id'))
target = document.part.rels[r_id].target_ref

# 转换为
LinkMark(type="link", href=target, range=[start, end])
```

---

## 二、段落格式精确映射

### 2.1 段落样式

| DOCX 属性 | python-docx API | StyleSheet 字段 | 值格式 |
|-----------|-----------------|-----------------|--------|
| **对齐方式** | `para.alignment` | `textAlign` | left/center/right/justify/distribute |
| **首行缩进** | `para.paragraph_format.first_line_indent` | `textIndent` | "2em" / "24pt" |
| **悬挂缩进** | 负值 first_line_indent | `textIndent` | "-24pt" (负值表示悬挂) |
| **左缩进** | `para.paragraph_format.left_indent` | `paddingLeft` | "48pt" |
| **右缩进** | `para.paragraph_format.right_indent` | `paddingRight` | "48pt" |
| **段前间距** | `para.paragraph_format.space_before` | `marginTop` | "12pt" / "1行" |
| **段后间距** | `para.paragraph_format.space_after` | `marginBottom` | "12pt" / "1行" |
| **行间距(倍数)** | `para.paragraph_format.line_spacing` | `lineHeight` | 1.5 / 2.0 |
| **行间距(固定)** | `para.paragraph_format.line_spacing_rule == EXACTLY` | `lineHeight` | "24pt" |
| **行间距(最小)** | `para.paragraph_format.line_spacing_rule == AT_LEAST` | `lineHeightMin` | "18pt" |
| **段落边框** | `para.paragraph_format.border_*` | `border*` | 边框样式 |
| **段落底纹** | `para.paragraph_format.shading.fill` | `backgroundColor` | RGB |
| **大纲级别** | `para.style.base_style...` | `outlineLevel` | 0-8 |
| **孤行控制** | `para.paragraph_format.widow_control` | `widowControl` | true/false |
| **段中不分页** | `para.paragraph_format.keep_together` | `keepTogether` | true/false |
| **与下段同页** | `para.paragraph_format.keep_with_next` | `keepWithNext` | true/false |
| **段前分页** | `para.paragraph_format.page_break_before` | `pageBreakBefore` | true/false |

### 2.2 制表位

```python
# 段落中的制表位
tab_stops = para.paragraph_format.tab_stops
for tab in tab_stops:
    # position: 位置 (Twips)
    # alignment: left/center/right/decimal
    # leader: none/dot/hyphen/underscore
```

存储格式:
```json
{
  "tabStops": [
    {"position": "72pt", "alignment": "left", "leader": "none"},
    {"position": "144pt", "alignment": "center", "leader": "dot"}
  ]
}
```

---

## 三、标题格式精确映射

### 3.1 标题识别

```python
def get_heading_level(paragraph) -> Optional[int]:
    """
    识别标题级别，支持多种方式：
    1. 内置标题样式: Heading 1, Heading 2, ...
    2. 大纲级别: outline_level
    3. 自定义样式判断
    """
    style_name = paragraph.style.name
    
    # 方式1: 内置样式
    if style_name.startswith('Heading'):
        return int(style_name.split()[-1])
    
    # 方式2: 大纲级别
    outline_level = get_outline_level(paragraph)
    if outline_level is not None and outline_level < 9:
        return outline_level + 1
    
    return None
```

### 3.2 标题存储

```json
{
  "id": "heading-xxx",
  "type": "heading",
  "level": 1,
  "text": "标题文本",
  "marks": [...],
  "attrs": {
    "outlineLevel": 0,
    "styleId": "Heading1"
  }
}
```

---

## 四、表格格式精确映射

### 4.1 表格级别属性

| DOCX 属性 | python-docx API | StyleSheet 字段 |
|-----------|-----------------|-----------------|
| **表格宽度** | `table.width` | `width` |
| **表格对齐** | `table.alignment` | `tableAlign` |
| **表格缩进** | `table.indent` | `marginLeft` |
| **边框折叠** | 默认 collapse | `borderCollapse` |
| **单元格间距** | `table.spacing` | `cellSpacing` |
| **表格布局** | `table.layout` | `tableLayout` (fixed/auto) |

### 4.2 列宽度（关键）

```python
def extract_column_widths(table) -> List[str]:
    """提取精确列宽"""
    widths = []
    
    # 方法1: tblGrid (推荐)
    grid = table._tbl.tblGrid
    for gridCol in grid.gridCol_lst:
        w = gridCol.get(qn('w:w'))  # Twips
        widths.append(twips_to_css(w))
    
    # 方法2: 从第一行单元格提取
    if not widths:
        for cell in table.rows[0].cells:
            widths.append(cell.width)
    
    return widths
```

存储格式:
```json
{
  "target": {"blockType": "tableColumn", "blockIds": ["table-1"], "columnIndex": 0},
  "style": {"width": "120pt"}
}
```

### 4.3 行高

```python
def extract_row_height(row) -> Tuple[str, str]:
    """提取行高和类型"""
    trPr = row._tr.trPr
    if trPr is not None:
        trHeight = trPr.trHeight
        if trHeight is not None:
            val = trHeight.get(qn('w:val'))  # Twips
            rule = trHeight.get(qn('w:hRule'), 'auto')  # auto/exact/atLeast
            return (twips_to_css(val), rule)
    return (None, 'auto')
```

存储格式:
```json
{
  "target": {"blockType": "tableRow", "blockIds": ["table-1"], "rowIndex": 0},
  "style": {"height": "24pt", "heightRule": "exact"}
}
```

### 4.4 单元格合并（关键）

```python
def extract_merge_regions(table) -> List[MergeRegion]:
    """精确提取合并单元格"""
    regions = []
    visited = set()
    
    for row_idx, row in enumerate(table.rows):
        for col_idx, cell in enumerate(row.cells):
            if (row_idx, col_idx) in visited:
                continue
            
            # 检查 gridSpan (横向合并)
            tc = cell._tc
            gridSpan = tc.get(qn('w:gridSpan'), 1)
            
            # 检查 vMerge (纵向合并)
            # vMerge="restart" 表示合并起始
            # vMerge="" 或无属性表示被合并
            vMerge = tc.tcPr.vMerge if tc.tcPr else None
            
            # 计算合并范围...
            if gridSpan > 1 or (vMerge and vMerge.val == 'restart'):
                region = calculate_merge_region(table, row_idx, col_idx)
                regions.append(region)
                # 标记已访问
                mark_visited(visited, region)
    
    return regions
```

### 4.5 单元格样式

| DOCX 属性 | python-docx API | StyleSheet 字段 |
|-----------|-----------------|-----------------|
| **背景色** | `cell.shading.fill` | `backgroundColor` |
| **垂直对齐** | `cell.vertical_alignment` | `verticalAlign` |
| **文字方向** | `cell.text_direction` | `writingMode` |
| **单元格边距** | `cell.margins.top/bottom/left/right` | `padding*` |
| **边框(上)** | `cell.border_top` | `borderTop*` |
| **边框(下)** | `cell.border_bottom` | `borderBottom*` |
| **边框(左)** | `cell.border_left` | `borderLeft*` |
| **边框(右)** | `cell.border_right` | `borderRight*` |
| **宽度** | `cell.width` | `width` |

#### 边框详细属性

```python
def extract_border(border) -> Dict:
    """提取边框完整信息"""
    return {
        "width": border.sz,      # 1/8 pt
        "style": border.val,     # single/double/dashed/dotted/...
        "color": border.color,   # RGB
        "space": border.space    # pt
    }
```

存储格式:
```json
{
  "target": {"blockType": "tableCell", "blockIds": ["cell-0-0"]},
  "style": {
    "borderTopWidth": "1pt",
    "borderTopStyle": "solid",
    "borderTopColor": "#000000",
    "backgroundColor": "#f0f0f0",
    "verticalAlign": "middle",
    "paddingTop": "3pt",
    "paddingBottom": "3pt",
    "paddingLeft": "5pt",
    "paddingRight": "5pt"
  }
}
```

---

## 五、列表格式精确映射

### 5.1 列表识别

```python
def get_list_info(paragraph) -> Optional[Dict]:
    """
    获取列表信息
    
    DOCX 列表通过 numPr (numId + ilvl) 定义
    """
    numPr = paragraph._p.pPr.numPr if paragraph._p.pPr else None
    if numPr is None:
        return None
    
    numId = numPr.numId.val
    ilvl = numPr.ilvl.val  # 列表层级
    
    # 从 numbering.xml 获取列表样式
    numbering_part = paragraph.part.numbering_part
    abstract_num = get_abstract_num(numbering_part, numId)
    
    lvl = abstract_num.lvl_lst[ilvl]
    num_fmt = lvl.numFmt.val  # decimal/bullet/lowerLetter/...
    
    return {
        "listType": "ordered" if num_fmt != "bullet" else "bullet",
        "listLevel": ilvl,
        "numFmt": num_fmt,
        "start": lvl.start.val if lvl.start else 1,
        "text": lvl.lvlText.val,  # "%1." / "•" / "(%1)"
        "indent": lvl.pPr.ind.left,
        "hangingIndent": lvl.pPr.ind.hanging
    }
```

### 5.2 列表存储

```json
{
  "id": "para-xxx",
  "type": "paragraph",
  "text": "列表项内容",
  "marks": [...],
  "attrs": {
    "listType": "ordered",
    "listLevel": 0,
    "listStart": 1,
    "listFormat": "%1.",
    "listNumFmt": "decimal"
  }
}
```

---

## 六、图片格式精确映射

### 6.1 图片属性

```python
def extract_image_info(inline_shape) -> Dict:
    """提取图片完整信息"""
    return {
        "width": inline_shape.width,     # EMU
        "height": inline_shape.height,   # EMU
        "alt": get_alt_text(inline_shape),
        "title": get_title(inline_shape),
        "position": "inline",  # inline/anchor
        "horizontalAlignment": get_h_align(inline_shape),
        "verticalAlignment": get_v_align(inline_shape),
        "wrapType": get_wrap_type(inline_shape),  # inline/tight/through/square/...
        "rotation": get_rotation(inline_shape),
        "flipH": is_flip_horizontal(inline_shape),
        "flipV": is_flip_vertical(inline_shape)
    }
```

### 6.2 图片存储

```json
{
  "id": "image-xxx",
  "type": "image",
  "src": "/api/v1/assets/images/{doc_id}/image001.png",
  "meta": {
    "width": "200pt",
    "height": "150pt",
    "alt": "图片描述",
    "originalWidth": "400pt",
    "originalHeight": "300pt",
    "rotation": 0,
    "wrapType": "inline"
  }
}
```

---

## 七、页面设置精确映射

### 7.1 节属性

```python
def extract_section_properties(section) -> Dict:
    """提取节属性"""
    return {
        # 页面尺寸
        "pageWidth": section.page_width,      # A4: 11906 Twips
        "pageHeight": section.page_height,    # A4: 16838 Twips
        "orientation": section.orientation,   # portrait/landscape
        
        # 页边距
        "marginTop": section.top_margin,
        "marginBottom": section.bottom_margin,
        "marginLeft": section.left_margin,
        "marginRight": section.right_margin,
        "marginHeader": section.header_distance,
        "marginFooter": section.footer_distance,
        "marginGutter": section.gutter,
        
        # 其他
        "columns": section.columns_count,
        "columnSpace": section.column_space
    }
```

---

## 八、单位转换

### 8.1 转换函数

```python
# 1 inch = 914400 EMU = 72 pt = 1440 Twips
# 1 pt = 20 Twips = 12700 EMU
# 1 cm = 360000 EMU

def emu_to_pt(emu: int) -> float:
    """EMU to points"""
    return emu / 12700

def twips_to_pt(twips: int) -> float:
    """Twips to points"""
    return twips / 20

def pt_to_px(pt: float, dpi: int = 96) -> float:
    """Points to pixels (screen)"""
    return pt * dpi / 72

def eighth_pt_to_pt(eighth: int) -> float:
    """1/8 point to points (用于边框宽度)"""
    return eighth / 8
```

### 8.2 存储原则

1. **保留原始单位**: 尽量使用 `pt` 作为统一单位，可从 pt 转换到其他单位
2. **记录原始值**: 对于关键尺寸，同时记录原始 EMU/Twips 值
3. **相对值**: 字号缩进等使用相对单位时保留（如 `2em`）

---

## 九、验证清单

### 导入验证

- [ ] 所有 Run 格式属性已提取
- [ ] 所有段落格式属性已提取
- [ ] 标题层级正确识别
- [ ] 表格行数、列数正确
- [ ] 列宽度精确提取
- [ ] 单元格合并正确识别
- [ ] 单元格样式完整提取
- [ ] 列表类型和层级正确
- [ ] 图片尺寸和位置正确
- [ ] 页面设置完整提取

### 还原验证

- [ ] 从 JSON 渲染的 HTML 格式与原文档一致
- [ ] 从 JSON 导出的 DOCX 格式与原文档一致（需实现导出功能）
